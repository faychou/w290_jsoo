1、函数基础
1.1 函数的创建
  >> 函数声明
    function 函数名() {}

  >> 函数表达式（箭头函数也属于这种）
    var 变量名 = function() {}

1.2 函数参数
  >> 形参
    创建函数时，设置的未知数。

  >> 实参
    调用函数时，给形参传递的数据。

  >> 参数默认值
    function 函数名(参数=默认值) {}

1.3 arguments 对象
  类似数组结构，保存了调用函数时传递的实参。

1.4 函数类型
  >> 返回值函数
    在函数中使用了 return 关键字，该关键字会返回后面的数据，并且之后的代码不会执行了。

  >> 匿名函数
    就是指没有名字的函数，函数表达式都是。

  >> 具名函数
    所有的声明都是具名。

  >> 回调函数
    setTimeout(function() {}, 0)

    fs.readFile(url, options, function() {})

1.5 IIFE
  >> 概念
    即立即执行函数表达式，属于匿名函数，创建后就会自动运行，且只能运行一次。

  >> 写法
    (function() {
      // 代码
    })()

    // or 
    (function() {
      // 代码
    }())

  >> 作用
    由于是函数，IIFE 中代码执行完毕后，内部的变量会销毁，就不会污染全局环境。

1.6 递归函数
  >> 概念
    在函数内部调用自己的一种场景。

  >> 写法
    function foo() {
      // ... 一堆逻辑
      foo();
    }

  >> 注意事项
    * 必须设置进口与出口，否则陷入死循环

  >> 应用
    * 如何利用 setTimeout 实现 setInterval 的功能
    * 多级菜单、树形菜单；
    * 累加、累乘；

1.7 惰性载入
用于减少每次执行代码时的重复性分支判断，通过对原函数或者源对象进行重新定义来避免。


2、作用域
2.1 概念
一段程序中所有用到的名字，这些名字的可以作用的范围就是作用域。

即变量或者函数可以发生作用的区域。

2.2 JS 执行环境
称为 执行上下文对象，程序运行时，就会产生这样的对象，用于管理函数和变量，决定了他们的生命周期以及访问数据的权限。

>> 全局执行环境
是属于最外围的执行环境。

一般执行两件事：
  * 创建全局对象（window）；
  * 初始化 this 等于这个全局对象；

>> 函数执行环境
函数运行时，会产生一个单独的环境，会将当前环境推入到执行栈中，代码运行完毕后，执行栈会弹出该环境。

2.3 根据执行环境又将作用域分为两类
  >> 全局作用域
    任意位置访问。

  >> 函数作用域（局部）
    只会在函数执行时有效，运行后相关变量都会被销毁，所以运行后不能再访问。

  >> 注意：ES6增加了 块级作用域
    是因为在 {} 中使用了 let/const 声明的变量

2.4 作用域链
作用域：如何查找变量/函数，确定对它的访问权限。

当查找变量/函数的时候，会先从当前上下文中寻找，如果没有找到，就找上一级上下文，一直找到全局上下文，如果都没有找到，就会报错。

注意：内部能够访问外部的变量，但是外部无法访问内部变量。


3、闭包（重难点）
3.1 概念
  其实是作用域的体现，能够区读取其他函数内部的变量。

  一般情况下，函数内部可以访问函数外变量，但是函数外不可以访问函数内的变量。但是可以通过一定的手段将内部变量暴露出来。

3.2 闭包写法
  >> 写法1，将内部的变量暴露给全局
    (function() {
      var 变量;
      window.方法 = function() {
        return 变量；
      }
    })()

  >> 写法2，将函数执行的结果返回
    var 变量 = (function() {
      var 变量;
      return function() {
          return 变量；
        }
    })()

3.3 闭包的特点
  * 函数嵌套函数；
  * 内层函数访问外层函数的数据；
  * 将内层函数暴露给全局；
  * 外层函数的数据被内层函数引用了，所以外层函数运行后，该变量不会被回收，常驻内存。

3.4 闭包的意义
  * 延长变量的生命周期；
  * 创建私有变量；

3.5 闭包产生的问题
  一般情况下函数运行后，内部的变量都会销毁。

  但是使用闭包后，由于内层函数引用外层函数的局部变量，导致该变量在外层函数运行后，不会被销毁，常驻内存，会造成性能问题，在IE浏览器中会导致内存泄露。

  所以：为了解决这个问题，应该在不使用该变量后，应该及时销毁（设置为 null）。

垃圾回收机制
https://juejin.cn/post/7025473557106802725?utm_source=gold_browser_extension